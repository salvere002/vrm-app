{"ast":null,"code":"import Vector from \"../utils/vector\";\nimport { PI } from \"./../constants\";\n/**\n * Calculate stable plane (triangle) from 4 face landmarks\n * @param {Array} lm : array of results from tfjs or mediapipe\n */\nexport const createEulerPlane = lm => {\n  //create face detection square bounds\n  const p1 = new Vector(lm[21]); //top left\n  const p2 = new Vector(lm[251]); //top right\n  const p3 = new Vector(lm[397]); //bottom right\n  const p4 = new Vector(lm[172]); //bottom left\n  const p3mid = p3.lerp(p4, 0.5); // bottom midpoint\n  return {\n    vector: [p1, p2, p3mid],\n    points: [p1, p2, p3, p4]\n  };\n};\n/**\n * Calculate roll, pitch, yaw, centerpoint, and rough dimentions of face plane\n * @param {Array} lm : array of results from tfjs or mediapipe\n */\nexport const calcHead = lm => {\n  // find 3 vectors that form a plane to represent the head\n  const plane = createEulerPlane(lm).vector;\n  // calculate roll pitch and yaw from vectors\n  const rotate = Vector.rollPitchYaw(plane[0], plane[1], plane[2]);\n  // find the center of the face detection box\n  const midPoint = plane[0].lerp(plane[1], 0.5);\n  // find the dimensions roughly of the face detection box\n  const width = plane[0].distance(plane[1]);\n  const height = midPoint.distance(plane[2]);\n  //flip\n  rotate.x *= -1;\n  rotate.z *= -1;\n  return {\n    //defaults to radians for rotation around x,y,z axis\n    y: rotate.y * PI,\n    x: rotate.x * PI,\n    z: rotate.z * PI,\n    width: width,\n    height: height,\n    //center of face detection square\n    position: midPoint.lerp(plane[2], 0.5),\n    //returns euler angles normalized between -1 and 1\n    normalized: {\n      y: rotate.y,\n      x: rotate.x,\n      z: rotate.z\n    },\n    degrees: {\n      y: rotate.y * 180,\n      x: rotate.x * 180,\n      z: rotate.z * 180\n    }\n  };\n};","map":{"version":3,"names":["Vector","PI","createEulerPlane","lm","p1","p2","p3","p4","p3mid","lerp","vector","points","calcHead","plane","rotate","rollPitchYaw","midPoint","width","distance","height","x","z","y","position","normalized","degrees"],"sources":["/Users/hzh-mac/Downloads/VRM/vrm-app/node_modules/kalidokit/dist/FaceSolver/calcHead.js"],"sourcesContent":["import Vector from \"../utils/vector\";\nimport { PI } from \"./../constants\";\n/**\n * Calculate stable plane (triangle) from 4 face landmarks\n * @param {Array} lm : array of results from tfjs or mediapipe\n */\nexport const createEulerPlane = (lm) => {\n    //create face detection square bounds\n    const p1 = new Vector(lm[21]); //top left\n    const p2 = new Vector(lm[251]); //top right\n    const p3 = new Vector(lm[397]); //bottom right\n    const p4 = new Vector(lm[172]); //bottom left\n    const p3mid = p3.lerp(p4, 0.5); // bottom midpoint\n    return {\n        vector: [p1, p2, p3mid],\n        points: [p1, p2, p3, p4],\n    };\n};\n/**\n * Calculate roll, pitch, yaw, centerpoint, and rough dimentions of face plane\n * @param {Array} lm : array of results from tfjs or mediapipe\n */\nexport const calcHead = (lm) => {\n    // find 3 vectors that form a plane to represent the head\n    const plane = createEulerPlane(lm).vector;\n    // calculate roll pitch and yaw from vectors\n    const rotate = Vector.rollPitchYaw(plane[0], plane[1], plane[2]);\n    // find the center of the face detection box\n    const midPoint = plane[0].lerp(plane[1], 0.5);\n    // find the dimensions roughly of the face detection box\n    const width = plane[0].distance(plane[1]);\n    const height = midPoint.distance(plane[2]);\n    //flip\n    rotate.x *= -1;\n    rotate.z *= -1;\n    return {\n        //defaults to radians for rotation around x,y,z axis\n        y: rotate.y * PI,\n        x: rotate.x * PI,\n        z: rotate.z * PI,\n        width: width,\n        height: height,\n        //center of face detection square\n        position: midPoint.lerp(plane[2], 0.5),\n        //returns euler angles normalized between -1 and 1\n        normalized: {\n            y: rotate.y,\n            x: rotate.x,\n            z: rotate.z,\n        },\n        degrees: {\n            y: rotate.y * 180,\n            x: rotate.x * 180,\n            z: rotate.z * 180,\n        },\n    };\n};\n"],"mappings":"AAAA,OAAOA,MAAM,MAAM,iBAAiB;AACpC,SAASC,EAAE,QAAQ,gBAAgB;AACnC;AACA;AACA;AACA;AACA,OAAO,MAAMC,gBAAgB,GAAIC,EAAE,IAAK;EACpC;EACA,MAAMC,EAAE,GAAG,IAAIJ,MAAM,CAACG,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;EAC/B,MAAME,EAAE,GAAG,IAAIL,MAAM,CAACG,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EAChC,MAAMG,EAAE,GAAG,IAAIN,MAAM,CAACG,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EAChC,MAAMI,EAAE,GAAG,IAAIP,MAAM,CAACG,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EAChC,MAAMK,KAAK,GAAGF,EAAE,CAACG,IAAI,CAACF,EAAE,EAAE,GAAG,CAAC,CAAC,CAAC;EAChC,OAAO;IACHG,MAAM,EAAE,CAACN,EAAE,EAAEC,EAAE,EAAEG,KAAK,CAAC;IACvBG,MAAM,EAAE,CAACP,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE;EAC3B,CAAC;AACL,CAAC;AACD;AACA;AACA;AACA;AACA,OAAO,MAAMK,QAAQ,GAAIT,EAAE,IAAK;EAC5B;EACA,MAAMU,KAAK,GAAGX,gBAAgB,CAACC,EAAE,CAAC,CAACO,MAAM;EACzC;EACA,MAAMI,MAAM,GAAGd,MAAM,CAACe,YAAY,CAACF,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,CAAC;EAChE;EACA,MAAMG,QAAQ,GAAGH,KAAK,CAAC,CAAC,CAAC,CAACJ,IAAI,CAACI,KAAK,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC;EAC7C;EACA,MAAMI,KAAK,GAAGJ,KAAK,CAAC,CAAC,CAAC,CAACK,QAAQ,CAACL,KAAK,CAAC,CAAC,CAAC,CAAC;EACzC,MAAMM,MAAM,GAAGH,QAAQ,CAACE,QAAQ,CAACL,KAAK,CAAC,CAAC,CAAC,CAAC;EAC1C;EACAC,MAAM,CAACM,CAAC,IAAI,CAAC,CAAC;EACdN,MAAM,CAACO,CAAC,IAAI,CAAC,CAAC;EACd,OAAO;IACH;IACAC,CAAC,EAAER,MAAM,CAACQ,CAAC,GAAGrB,EAAE;IAChBmB,CAAC,EAAEN,MAAM,CAACM,CAAC,GAAGnB,EAAE;IAChBoB,CAAC,EAAEP,MAAM,CAACO,CAAC,GAAGpB,EAAE;IAChBgB,KAAK,EAAEA,KAAK;IACZE,MAAM,EAAEA,MAAM;IACd;IACAI,QAAQ,EAAEP,QAAQ,CAACP,IAAI,CAACI,KAAK,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC;IACtC;IACAW,UAAU,EAAE;MACRF,CAAC,EAAER,MAAM,CAACQ,CAAC;MACXF,CAAC,EAAEN,MAAM,CAACM,CAAC;MACXC,CAAC,EAAEP,MAAM,CAACO;IACd,CAAC;IACDI,OAAO,EAAE;MACLH,CAAC,EAAER,MAAM,CAACQ,CAAC,GAAG,GAAG;MACjBF,CAAC,EAAEN,MAAM,CAACM,CAAC,GAAG,GAAG;MACjBC,CAAC,EAAEP,MAAM,CAACO,CAAC,GAAG;IAClB;EACJ,CAAC;AACL,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}