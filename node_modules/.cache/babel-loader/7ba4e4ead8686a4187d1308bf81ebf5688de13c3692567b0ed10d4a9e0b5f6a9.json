{"ast":null,"code":"import Vector from \"../utils/vector\";\nimport Euler from \"../utils/euler\";\nimport { clamp } from \"../utils/helpers\";\nimport { RIGHT, LEFT } from \"./../constants\";\nimport { PI } from \"./../constants\";\nexport const offsets = {\n  upperLeg: {\n    z: 0.1\n  }\n};\n/**\n * Calculates leg rotation angles\n * @param {Results} lm : array of 3D pose vectors from tfjs or mediapipe\n */\nexport const calcLegs = lm => {\n  const rightUpperLegSphericalCoords = Vector.getSphericalCoords(lm[23], lm[25], {\n    x: \"y\",\n    y: \"z\",\n    z: \"x\"\n  });\n  const leftUpperLegSphericalCoords = Vector.getSphericalCoords(lm[24], lm[26], {\n    x: \"y\",\n    y: \"z\",\n    z: \"x\"\n  });\n  const rightLowerLegSphericalCoords = Vector.getRelativeSphericalCoords(lm[23], lm[25], lm[27], {\n    x: \"y\",\n    y: \"z\",\n    z: \"x\"\n  });\n  const leftLowerLegSphericalCoords = Vector.getRelativeSphericalCoords(lm[24], lm[26], lm[28], {\n    x: \"y\",\n    y: \"z\",\n    z: \"x\"\n  });\n  const hipRotation = Vector.findRotation(lm[23], lm[24]);\n  const UpperLeg = {\n    r: new Vector({\n      x: rightUpperLegSphericalCoords.theta,\n      y: rightLowerLegSphericalCoords.phi,\n      z: rightUpperLegSphericalCoords.phi - hipRotation.z\n    }),\n    l: new Vector({\n      x: leftUpperLegSphericalCoords.theta,\n      y: leftLowerLegSphericalCoords.phi,\n      z: leftUpperLegSphericalCoords.phi - hipRotation.z\n    })\n  };\n  const LowerLeg = {\n    r: new Vector({\n      x: -Math.abs(rightLowerLegSphericalCoords.theta),\n      y: 0,\n      z: 0 // not relevant\n    }),\n\n    l: new Vector({\n      x: -Math.abs(leftLowerLegSphericalCoords.theta),\n      y: 0,\n      z: 0 // not relevant\n    })\n  };\n  //Modify Rotations slightly for more natural movement\n  const rightLegRig = rigLeg(UpperLeg.r, LowerLeg.r, RIGHT);\n  const leftLegRig = rigLeg(UpperLeg.l, LowerLeg.l, LEFT);\n  return {\n    //Scaled\n    UpperLeg: {\n      r: rightLegRig.UpperLeg,\n      l: leftLegRig.UpperLeg\n    },\n    LowerLeg: {\n      r: rightLegRig.LowerLeg,\n      l: leftLegRig.LowerLeg\n    },\n    //Unscaled\n    Unscaled: {\n      UpperLeg,\n      LowerLeg\n    }\n  };\n};\n/**\n * Converts normalized rotation values into radians clamped by human limits\n * @param {Object} UpperLeg : normalized rotation values\n * @param {Object} LowerLeg : normalized rotation values\n * @param {Side} side : left or right\n */\nexport const rigLeg = function (UpperLeg, LowerLeg) {\n  let side = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : RIGHT;\n  const invert = side === RIGHT ? 1 : -1;\n  const rigedUpperLeg = new Euler({\n    x: clamp(UpperLeg.x, 0, 0.5) * PI,\n    y: clamp(UpperLeg.y, -0.25, 0.25) * PI,\n    z: clamp(UpperLeg.z, -0.5, 0.5) * PI + invert * offsets.upperLeg.z,\n    rotationOrder: \"XYZ\"\n  });\n  const rigedLowerLeg = new Euler({\n    x: LowerLeg.x * PI,\n    y: LowerLeg.y * PI,\n    z: LowerLeg.z * PI\n  });\n  return {\n    UpperLeg: rigedUpperLeg,\n    LowerLeg: rigedLowerLeg\n  };\n};","map":{"version":3,"names":["Vector","Euler","clamp","RIGHT","LEFT","PI","offsets","upperLeg","z","calcLegs","lm","rightUpperLegSphericalCoords","getSphericalCoords","x","y","leftUpperLegSphericalCoords","rightLowerLegSphericalCoords","getRelativeSphericalCoords","leftLowerLegSphericalCoords","hipRotation","findRotation","UpperLeg","r","theta","phi","l","LowerLeg","Math","abs","rightLegRig","rigLeg","leftLegRig","Unscaled","side","arguments","length","undefined","invert","rigedUpperLeg","rotationOrder","rigedLowerLeg"],"sources":["/Users/hzh-mac/Downloads/VRM/vrm-app/node_modules/kalidokit/dist/PoseSolver/calcLegs.js"],"sourcesContent":["import Vector from \"../utils/vector\";\nimport Euler from \"../utils/euler\";\nimport { clamp } from \"../utils/helpers\";\nimport { RIGHT, LEFT } from \"./../constants\";\nimport { PI } from \"./../constants\";\nexport const offsets = {\n    upperLeg: {\n        z: 0.1,\n    },\n};\n/**\n * Calculates leg rotation angles\n * @param {Results} lm : array of 3D pose vectors from tfjs or mediapipe\n */\nexport const calcLegs = (lm) => {\n    const rightUpperLegSphericalCoords = Vector.getSphericalCoords(lm[23], lm[25], { x: \"y\", y: \"z\", z: \"x\" });\n    const leftUpperLegSphericalCoords = Vector.getSphericalCoords(lm[24], lm[26], { x: \"y\", y: \"z\", z: \"x\" });\n    const rightLowerLegSphericalCoords = Vector.getRelativeSphericalCoords(lm[23], lm[25], lm[27], {\n        x: \"y\",\n        y: \"z\",\n        z: \"x\",\n    });\n    const leftLowerLegSphericalCoords = Vector.getRelativeSphericalCoords(lm[24], lm[26], lm[28], {\n        x: \"y\",\n        y: \"z\",\n        z: \"x\",\n    });\n    const hipRotation = Vector.findRotation(lm[23], lm[24]);\n    const UpperLeg = {\n        r: new Vector({\n            x: rightUpperLegSphericalCoords.theta,\n            y: rightLowerLegSphericalCoords.phi,\n            z: rightUpperLegSphericalCoords.phi - hipRotation.z,\n        }),\n        l: new Vector({\n            x: leftUpperLegSphericalCoords.theta,\n            y: leftLowerLegSphericalCoords.phi,\n            z: leftUpperLegSphericalCoords.phi - hipRotation.z,\n        }),\n    };\n    const LowerLeg = {\n        r: new Vector({\n            x: -Math.abs(rightLowerLegSphericalCoords.theta),\n            y: 0,\n            z: 0, // not relevant\n        }),\n        l: new Vector({\n            x: -Math.abs(leftLowerLegSphericalCoords.theta),\n            y: 0,\n            z: 0, // not relevant\n        }),\n    };\n    //Modify Rotations slightly for more natural movement\n    const rightLegRig = rigLeg(UpperLeg.r, LowerLeg.r, RIGHT);\n    const leftLegRig = rigLeg(UpperLeg.l, LowerLeg.l, LEFT);\n    return {\n        //Scaled\n        UpperLeg: {\n            r: rightLegRig.UpperLeg,\n            l: leftLegRig.UpperLeg,\n        },\n        LowerLeg: {\n            r: rightLegRig.LowerLeg,\n            l: leftLegRig.LowerLeg,\n        },\n        //Unscaled\n        Unscaled: {\n            UpperLeg,\n            LowerLeg,\n        },\n    };\n};\n/**\n * Converts normalized rotation values into radians clamped by human limits\n * @param {Object} UpperLeg : normalized rotation values\n * @param {Object} LowerLeg : normalized rotation values\n * @param {Side} side : left or right\n */\nexport const rigLeg = (UpperLeg, LowerLeg, side = RIGHT) => {\n    const invert = side === RIGHT ? 1 : -1;\n    const rigedUpperLeg = new Euler({\n        x: clamp(UpperLeg.x, 0, 0.5) * PI,\n        y: clamp(UpperLeg.y, -0.25, 0.25) * PI,\n        z: clamp(UpperLeg.z, -0.5, 0.5) * PI + invert * offsets.upperLeg.z,\n        rotationOrder: \"XYZ\",\n    });\n    const rigedLowerLeg = new Euler({\n        x: LowerLeg.x * PI,\n        y: LowerLeg.y * PI,\n        z: LowerLeg.z * PI,\n    });\n    return {\n        UpperLeg: rigedUpperLeg,\n        LowerLeg: rigedLowerLeg,\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}